\documentclass[11pt]{llncs}

\usepackage{amsmath}
\usepackage{amssymb}
\usepackage{multicol}

\newcommand{\SET}[1]{\{#1\}}
\newcommand*{\PSET}[2]{\{\,#1\mid#2\,\}}

\newcommand{\score}{\operatorname{score}}
\newcommand{\argmax}{\operatorname*{arg max}}

\addtolength{\hoffset}{-0.6cm}
\addtolength{\textwidth}{1.2cm}
\addtolength{\voffset}{-1.05cm}
\addtolength{\textheight}{2.1cm}

%\newcommand{\ale}[1]{{\bfseries [Ale:\ #1]}}
\newcommand{\mm}[1]{{\bfseries [Mathias:\ #1]}}
\title{Alignment of RNA with Structures of Unlimited Complexity}

\author{Alessandro Dal Pal{\`u}$^1$, Mathias M{\"o}hl$^2$, and Sebastian Will$^{2,3}$}

\institute{Dipartimento di Matematica, Universit\`a  degli Studi di
  Parma, Parma, Italy, \email{alessandro.dalpalu@unipr.it} \and
  Bioinformatics, Institute of Computer Science,
  Albert-Ludwigs-Universit\"{a}t, Freiburg, Germany,
  \email{\{mmohl,will\}@informatik.uni-freiburg.de} \and Computation and
  Biology Lab, CSAIL, MIT, Cambridge MA, USA,
  \email{swill@csail.mit.edu}}

\begin{document}
\maketitle

\begin{abstract}
  Sequence-structure alignment of RNA with arbitrary secondary
  structure is Max-SNP-hard. Therefore, the problem of RNA alignment
  is commonly restricted to nested structure, where dynamic
  programming yields efficient solutions. However, nested structure
  cannot model pseudoknots or even more complex structural
  dependencies.  Nevertheless those dependencies are essential and
  conserved features of many RNAs. Only a few existing approaches deal
  with crossing structures. Here, we present a constraint approach for
  alignment of structures in the even more general class of unlimited
  structures.  Our central contribution is a new RNA alignment
  constraint propagator. It is based on an efficient $O(n^2)$
  relaxation of the RNA alignment problem. Our constraint-based
  approach Carna solves the alignment problem for sequences with given
  input structures of unlimited complexity. Carna is implemented using
  Gecode.
\end{abstract}

In the post-genomic era, biologists get more and more interested in
studying non-coding RNA molecules with catalytic and regulatory
activity as central players in biological systems.
%
The computational analysis of non-coding RNA requires to take
structural information into account.
% is more involved than the analysis of DNA
%and proteins, because many non-coding RNAs, like proteins, form
%structure that is essential for their function and is consequently
%evolutionary conserved. However, unlike for proteins, it is much more
%common for homologuous non-coding RNAs that their similarity is barely
%visible at the sequence level but almost exclusively in their
%structure.
%
Whereas RNAs form three-dimensional structures, structural analysis of
RNA is usually concerned with the secondary structure of an RNA, i.e.
the set of RNA base pairs $(i,j)$ that form contacts (H-bonds) between
the bases $i$ and $j$. The RNA alignment problem is to align two RNA
sequences $A$ and $B$ with given secondary structure for each RNA such
that a score based on sequence and structure similarity is
optimized. The difficulty of this problem depends on the complexity of
the RNA structures. Therefore, a complexity hierarchy of RNA
structures was introduced. Most RNA analysis is performed for the
class of nested structures $P$, where base-pairs do not cross, because
for this class one can find efficient dynamic programming algorithms
for structure prediction and alignment under reasonable scoring
schemes~\cite{Zuker:Stiegler:Optim_compu_foldi:NAR1981,Jiang:Lin:Ma:Gener_Edit_Dista:JCB2002}. The
more general class of crossing RNA structures $P$ restricts the degree
of base pairing to at most one, as is commonly assumed for single
RNA structure. Prediction and alignment in this class is NP-hard in
general~\cite{blin07:_exten_hardn_rna_secon_struc_compar}. However,
one can devise a number of algorithms that efficiently predict or
align RNAs with structures from classes in between non-crossing and
arbitrary
crossing~\cite{Rivas:Eddy:dynam_progr_algor:JMB1999,Reeder:Giegerich:Desig_imple_and:2004,Moehl:Will:Backofen:PKalign:JCB2010}. However
these algorithms have complexities that limit their application range.
Other approaches for RNA alignment handle crossing structures with
parametrized complexity, were the parameter captures the complexity
of the
structures~\cite{%Evans:finding:CPM99,
Moehl:Will:Backofen:CPM2008}.
%A different approach is to handle nested structures with
%parametrized complexity, where the parameter describes the complexity
%of the structure(s), an example is~\cite{Moehl:Will:Backofen:CPM2008}
%for alignment.  
Finally, the ILP approach
Lara~\cite{Bauer:Klau:Reinert:Accur_multi_seque:2007} computes
alignments of arbitrarily complex crossing structures and appears to be more
effective than dynamic programming based approaches.  The success of
this AI technique was a strong motivation for this work, where we
study the alignment of RNAs with structures of unlimited complexity
using constraint programming.
\paragraph{Contribution} We devise a constraint algorithm for the
problem of aligning two RNA molecules with given sequences and
unlimited secondary structures. By modeling and propagating
constraints on integers, the method goes beyond rephrasing the ILP
approach~\cite{Bauer:Klau:Reinert:Accur_multi_seque:2007} in CP. We
describe the constraint model, develop a new RNA alignment propagator,
and present a specific search strategy. It is implemented using the
Gecode constraint programming system. Finally, we give preliminary
results of our approach.

\section{Methods}

\subsection{Preliminaries}
An \emph{RNA sequence} $S$ is a string over the set of bases
$\{A,U,C,G\}$ and an \emph{RNA structure} $P$ is a set of \emph{base
  pairs} (also called \emph{arcs}) $(i,j)$ with $1 \leq i< j \leq
|S|$. We define an \emph{arc-annotated sequence} as pair of RNA sequence
and RNA structure and denote the $i$-th symbol of $S$ by $S[i]$.

One constructs a hierarchy of RNA structure classes based on the
following properties. Two arcs $(i,j)$ and $(i',j')$ are called
\emph{nested} iff $i<i'<j'<j$ or $i'<i<j<j'$, they are
\emph{independent} iff $i<j<i'<j'$ or $i'<j'<i<j$.
%
A RNA structure $P$ is called \emph{nested} if all differing base
pairs $(i,j),(i',j')\in P$ are either nested or independent.  In a
crossing RNA structure $P$ each base is involved in at most one base
pair, i.e. $\forall (i,j)\neq(i',j')\in P: i\neq i' \land j\neq j'
\land i\neq j \land i'\neq j'$. We use the term \emph{unlimited} to
refer to an arbitrary RNA structure. Note that by definition each
nested structure is crossing, and each crossing structure is
unlimited, such that these classes form a class hierarchy.

%%%%%%%%%%%%%%%%%%%%%%%%% ALIGNMENT (OF ENTIRE SEQUENCES)
An \emph{alignment $A$} of two \emph{arc-annotated sequences}
$(S_a,P_a)$ and $(S_b,P_b)$ is a set $A_m\cup A_g$, where
$A_m\subseteq [1..|S_a|] \times [1..|S_b|]$ is a set of \emph{match
  edges} such that for all $(i,j),(i',j')\in A_m$ it holds that 1.)
$i>i'$ implies $j>j'$ and 2.)  $i=i'$ if and only if $j=j'$ and $A_g$
is the set of \emph{gap edges} $\PSET{(x,-)}{x\in [1..|S_a|]\land
  \nexists y: (x,y)\in A_m}\cup\PSET{(-,y)}{y\in [1..|S_b|]\land
  \nexists x: (x,y)\in A_m}$.
%
We define the \emph{$(i,i')$-prefix of $A$} as
$A\cap(\PSET{(j,j')}{j\leq i,j'\leq i'}\cup\PSET{(j,-)}{j\leq i}\cup\PSET{(-,j')}{j'\leq i'})$
and the  \emph{$(i,i')$-suffix of $A$} as
$A\cap(\PSET{(j,j')}{j>i,j'>i'}\cup\PSET{(j,-)}{j>i}\cup\PSET{(-,j')}{j'>i'})$.


%% Define alignment problem, i.p. scoring for unlimited structure.
Fix two arc-annotated sequences $(S_a,P_a)$ and $(S_b,P_b)$ with
unlimited structures $P_a$ and $P_b$. Define the score of alignment $A$
of $(S_a,P_a)$ and $(S_b,P_b)$ as
\begin{displaymath}
  \score(A_m\cup A_g) :=
  \sum_{(i,i')\in A_m} \sigma(i,i')
  + \sum_{\substack{(i,j)\in P_a,(i',j')\in P_b,\\(i,i')\in A_m,(j,j')\in A_m}} \tau(i,j,i',j')
  \quad + \quad\gamma |A_g|,
\end{displaymath}
where $\sigma(i,j)$ is the similarity of bases $S_a[i]$ and $S_b[j]$,
$\tau(i,j,i',j')$ is the similarity of base pairs $(i,j)\in P_a$
and $(i',j')\in P_b$ and $\gamma$ is the gap cost.
% For $i'<i$, define $\tau(i',i,j',j):=\tau(i,i',j,j')$.
Commonly, scores for sequence-structure alignment penalize the base
match of different bases but don't penalize the same match if it
occurs as part of a base pair match. We emphasize that our scoring
function can express such scores, in the same way as scoring functions
that don't add base similarity in case of a structural base match.
For example, if bases $A_i$ and $B_i'$ differ, the negative
contribution by $\sigma(i,i')$ can be compensated by $\tau(i,i',j,j')$
in a structural match.


The \emph{alignment problem} is to determine
\begin{math}
  \displaystyle\argmax_{\text{$A$ alignment of $(S_a,P_a)$ and $(S_b,P_b)$}} \score(A).
\end{math}\\[3pt]
%
Please note that we score the matches of all base pairs that are
matched by the alignment. Given unlimited structures $P_a$ and $P_b$,
our approach is thus able to simultaneously take into account several
biologically relevant RNA structures per sequence. In contrast,
Lara~\cite{Bauer:Klau:Reinert:Accur_multi_seque:2007} would select a
single, best crossing RNA structure for each sequence and score the
match of only those structures. This assumes that there is only one
conserved crossing structure for each RNA. The potential advantages of
our scoring for aligning RNAs with conserved unlimited structure have
still to be explored (see Discussion). For the special case of
crossing structures with positive weights there is no difference
between the scoring by our approach and Lara, because in this case
Lara scores the matches of all base pairs matched by the
alignment. This justifies our direct comparison of the two approaches
for this case.


\newcommand{\var}{\texttt}
\newcommand{\cA}{{\mathcal A}}
\subsection{Constraint Model}

We model an alignment of arc-annotated sequences $(S_a,P_a)$ and
$(S_b,P_b)$ by variables $\var{MD}_i$ and $\var{M}_i$ for $1\leq i\leq
|S_a|$ with initial domains $D(\var{MD}_i) = \{1,\dots,|S_b|\}$ and
$D(\var{M}_i)=\{0,1\}$. We write $\vec{MD}$ and $\vec{M}$ to
denote the vectors of respective variables $\var{MD}_i$ and
$\var{M}_i$.

A valuation $V$ of these variables corresponds to a class $\cA(V)$ of
alignments $A$ of $(S_a,P_a)$ and $(S_b,P_b)$ as defined by
\begin{align*}
  V(\var{MD}_i)=j \land V(\var{M}_i)=1 &\text{ iff } (i,j) \in A  \\
  V(\var{MD}_i)=j \land V(\var{M}_i)=0 &\text{ iff } (i,-) \in A \\&\quad\land \forall (i',j')\in A: i'< i \rightarrow j'\leq j \land i'>i \rightarrow j'>j.
\end{align*}

In this way, $M_i$ tells whether $i$ is matched or deleted and the
value $j$ of $MD_i$ tells that $i$ is matched to $j$ or deleted after
$j$. One can show that $\cA(V)$ has at most one element and that for
each alignment $A$ of $(S_a,P_a)$ and $(S_b,P_b)$ there is a
corresponding valuation.

For example, the following alignment and valuation correspond to each
other: $A=\{(1,1),(-,2),(-,3),(2,4),(3,-),(4,5)\}$, which is often written as
$\begin{array}{c}
\texttt{A--CUG}\\
\texttt{ACAC-G}
\end{array},$
corresponds to the valuation $\vec{MD}=(1,4,4,5)$ and $\vec{M}=(1,1,0,1)$.

Notably, alignments corresponding to a valuation that assigns $MD_i=j$
can be composed from an alignment of prefixes $S_a[1..i]$ and
$S_b[1..j]$ and an alignment of suffixes $S_a[i+1..|S_a|]$ and $S_b[j+1..|S_b|]$
regardless of $\var{M}_i$.

We introduce a constraint \texttt{Alignment}$(\vec{MD},\vec{M})$ that
is satisfied by any valuation with a corresponding alignment.
Furthermore, we model the score of the alignment. Therefore, we
introduce a variable $\var{Score}$ and a constraint
\texttt{AlignmentScore}$(\vec{MD},\vec{M},\var{Score})$. This
constraint relates a valuation of $\var{MD}$ and $\var{M}$ to the
score of its corresponding alignment.

Both constraints are propagated by the propagator of the next
subsection. For finding optimal alignments we perform a depth-first
branch-and-bound search enumerating $\var{MD}$ and $\var{M}$ according
to a specific search strategy described at the end of the next
section. Successfully applying branch-and-bound requires good upper
bounds for the alignment score, such that large parts of the search
tree can be pruned. Computing such bounds efficiently is the central
job of the alignment propagator.

\subsection{The Alignment Propagator}

The alignment propagator computes hyper-arc consistency for the constraint
\texttt{Alignment}$(\vec{MD},\vec{M})$ and propagates
\texttt{AlignmentScore}$(\vec{MD},\vec{M},\var{Score})$.

It prunes $\vec{MD}$ and $\vec{M}$ due to the score by computing upper
score bounds for single variable assignments and furthermore computes
lower and upper bounds for $\var{Score}$ based on $\vec{MD}$ and
$\vec{M}$.

Define the class $\cA(D)$ as union of $\cA(V)$ over all valuations $V$
that satisfy $D$. The computation of bounds is based on a relaxation of
the alignment problem. In this relaxation the two ends of each base
pair match are decoupled. Thus in the \emph{relaxed optimization
  problem for $D$}, we maximize a relaxed score
\vspace{-6pt}
 \begin{displaymath}
  \score_\text{relaxed}(A_m\cup A_g) :=
  \sum_{(i,i')\in A_m} \left[
  \sigma(i,i') + \frac{1}{2}\operatorname{ub}_D(i,i') \right]
  \quad + \quad \gamma |A_g|,
\end{displaymath}
\vspace{-8pt}
over all alignments in $\cA(D)$, where
\begin{displaymath}
  \operatorname{ub}_D(i,i') :=\! \max_{A_m\cup A_g\in\cA(D)} \sum_{\substack{(i,j)\in P_a,(i',j')\in P_b,\\(i,i')\in A_m,(j,j')\in A_m}} \!\!\!\tau(i,j,i',j')\,\,\,
   + \!\!\!\sum_{\substack{(j,i)\in P_a,(j',i')\in P_b,\\(i,i')\in A_m,(j,j')\in A_m}} \!\!\!\tau(j,i,j',i').
\end{displaymath}

Here, $\operatorname{ub}_D$ works as an upper bound for the score
contributions by arc matches involving $(i,i')$ and consequently
$\score_\text{relaxed}(A) \geq \score(A)$ for $A\in\cA(D)$. Thus,
solving the relaxed problem yields an upper bound of \var{Score}.

For a moment, postpone how to efficiently compute
$\operatorname{ub}_D(i,i')$. Then, because the relaxed score has
the form of a sequence similarity score, one can apply the
Smith-Waterman algorithm~\cite{smith81:_compar_bioseq} to maximize the
relaxed score in $O(n^2)$ by dynamic programming, where
$n=\max(|S_a|,|S_b|)$. The optimization problem is easily constrained
due to domain $D$, because domains directly restrict the valid cases
in the dynamic programming recursion.

Tracing back through the dynamic programming matrix yields an alignment
$A^l$ such that $\score{A^l}$ is a lower bound of $\var{Score}$.
%
Furthermore, we compute upper bounds for each single variable
valuation. This requires to complement the above ``forward algorithm''
that computes the matrix entries
\vspace{-4pt}
\begin{displaymath}
  \operatorname{Prefix}{(i,i')} := \max_{\text{$(i,i')$-prefix
      $A^p_{ii'}$ of }A\in\cA(D)} \score_\text{relaxed}(A^p_{ii'})\\[-6pt]
\end{displaymath}
by a symmetric ``backward algorithm'' that computes the entries
\begin{math}
 \operatorname{Suffix}{(i,i')} :=
  \max_{\text{$(i,i')$-suffix $A^s_{ii'}$ of }A\in\cA(D)}
  \score_\text{relaxed}(A^s_{ii'}).
\end{math}

Now the variables $\vec{MD}$ can be pruned efficiently, because
$\operatorname{Prefix}{(i,i')}+\operatorname{Suffix}{(i,i')}$ is an
upper bound for the assignment $\var{MD}_i=j$. Similarly, we prune
$\vec{M}$ using the two matrices.

It remains to describe the efficient computation of
$\operatorname{ub}_D(i,i')$. It suffices to describe the
maximization of $\sum_{\substack{(i,j)\in P_a,(i',j')\in
    P_b,\\(i,i')\in A_m,(j,j')\in A_m}} \tau(i,j,i',j')$ 
over alignments in $\cA(D)$. A single match $(j,j')$ can occur in an
alignment in $\cA(D)$ if $j'\in D(\var{MD}_j)$ and $1\in
D(\var{M}_j)$. However, we look for the best set of simultaneously
valid matches $(j,j')$. The structure of this subproblem is analogous
to sequence alignment. Thus, it is solved efficiently by dynamic
programming.
%% maybe give recursion equation? add details later
Therefore, $\operatorname{ub}(i,i')$ is computed in $O(kk')$
time, where $k$ and $k'$ are the respective number of base pairs
incident to $i$ and $i'$. For many applications $k$ and $k'$ can be
constantly bounded such that the propagator runs in $O(n^2)$ time and
space.

\paragraph{Incrementality}
The propagator profits from reduced domain sizes of the variables
$\vec{MD}$, because $\operatorname{Prefix}{(i,i')}$ is finite only if
$i'\in D(\var{MD}_i)$ and the Suffix-matrix is analogously
restricted. The complexity of the propagator is therefore given more
precisely as $O(\sum_{i=1}^{|S_a|}|D(\var{MD}_i)|)$. We postponed the
idea of incrementally updating the matrices according to domain
changes, because we expect large domain changes due to our
propagator. Large domain changes would likely counteract the benefits
of matrix updates.

\paragraph{Affine gap cost}
The method is straightforwardly extended to affine gap cost by using a
Gotoh-like forward and backward algorithm in the propagator without
increasing its complexity. It appears that this modification comes
more natural in our approach than the corresponding extension in ILP,
because it does not require any change of the model.

\paragraph{Propagator-guided search strategy}
%Idea of guiding the search by backtrace.
Our search strategy guides the search to disprove overestimated bounds
fast and to find valid good alignments quickly. Because information
for achieving both goals is computed during propagation and is
expensive to recompute, we reuse propagation results for guiding the
search. We select a variable with large domain size that yields a high
undecided contribution to the upper bound. We split the domain of this
variable to select the 20\% highest relaxed scores first.

%\subsection{Visualization of partial solutions}

%\subsection{Implementation details}
%Use of LocARNA code.

%Hacks that were applied to make things work in Gecode.

\section{Results}

The method, called Carna, is implemented in C++ using the constraint
programming system Gecode. For handling input and output as well as
for special datastructures we reused code of
LocARNA~\cite{Will:etal:_infer_non_codin_rna_famil:PLOS2007}.

We run tests for two application scenarios. First, we explore Carna's
behavior on crossing input structure using instances from all 16 Rfam
families with crossing structure. Table~\ref{tab:results} compares our
results to Lara~\cite{Bauer:Klau:Reinert:Accur_multi_seque:2007}. The
table omits all 8 instances where both approaches run in less than 0.1
seconds.  In all but one of the omitted cases, Carna solves the
problem without backtracking. In terms of performance, both programs
are on a par. However, we want to emphasize that, in contrast to Lara, which
heuristically limits its run-time, Carna always solves the problem to
optimality. This explains behavior as for tmRNA in
Table~\ref{tab:results}.

In our second scenario, we align dot-plot matrices as computed by
RNAfold\cite{Hofacker:Fontana:Stadler:Bonhoeffer:Tacker:Schuster:MonChem1994}. We
obtain unlimited input structures by base pair filtering as e.g. done
in LocARNA. As in LocARNA and
PMcomp~\cite{Hofacker:Bernhart:Stadler:Align_RNA_base:2004} base pair
similarities are weighted according to the base pair
probabilities. This results in alignments that are guided by the
common structural potential of both RNAs and not only a single common
structure. We align two tRNAs closing the search tree after nine
nodes. Two TPP riboswitches of sizes 108 and 111 are aligned in 0.24
seconds closing the tree after 100 nodes.

\begin{table}
  \centering
  \begin{tabular}{c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}|@{\hspace{6pt}}c@{\hspace{6pt}}}
    Family
    & \multicolumn{2}{@{\hspace{-6pt}}|@{\hspace{-3pt}}c@{\hspace{3pt}}}{Lengths}
    & \multicolumn{2}{@{\hspace{-6pt}}|@{\hspace{-3pt}}c@{\hspace{3pt}}}{Run-time (s)}
    & \multicolumn{4}{@{\hspace{-6pt}}|@{\hspace{-3pt}}c}{Carna Search Tree} \\
    \hline\hline
                     &$S_a$&$S_b$& Carna& Lara & Depth & Sols & Fails & Size\\ %% user time
    \hline
    %Alpha\_RBS       & 109 & 106 & 0.06 & 0.03 & 63 & 5 & 59 & 63 \\
    %Antizyme\_FSE    &  59 &  56 & 0.00 & 0.01 &  0 & 1 &  0 &  0 \\
    %Corona\_FSE      &  79 &  87 & 0.01 & 0.02 & 22 & 1 & 22 & 22 \\
    %Corona\_pk3      &  62 &  63 & 0.05 & 0.01 & 18 & 1 & 18 & 18 \\
    Entero\_OriR     & 126 & 130 & 0.03 & 0.18 & 46 & 5 & 42 & 46 \\
    Intron\_gpI      & 443 & 436 & 0.1  & 0.2  & 0  & 1 &  0 &  0 \\
    IRES\_Cripavirus & 202 & 199 & 0.2  & 0.04 &204 &12 &221 &232 \\
    %Parecho\_CRE     & 113 & 115 & 0.04 & 0.03 & 71 & 1 & 71 & 71 \\
    %Prion\_pknot     &  41 &  41 & 0.0  & 0.03 & 7  & 1 &  7 &  7 \\
    RNaseP\_arch     & 303 & 367 & 0.5  & 1.4  & 66 & 1 & 66 & 66 \\
    RNaseP\_bact\_b  & 408 & 401 & 4.4  & 2.3  &416 &23 &1282&1304\\
    RNaseP\_nuc      & 317 & 346 & 0.07 & 2.9  & 29 & 2 & 28 & 29 \\
    %RydC             &  64 &  66 & 0.01 & 0.0  & 0  & 1 & 0  & 0  \\
    Telomerase-vert  & 448 & 451 & 0.56 & 2.3  &181 & 7 &175 &181 \\
    tmRNA            & 384 & 367 & 76   & 3.7  &478 &28 &18937&18964\\
    %Tymo\_tRNA-like  &  84 &  84 & 0.02 & 0.02 &67  & 1 & 67 & 67\\
  \end{tabular}\\[6pt]
  \caption{Results for the eight hardest instances of the benchmark set with crossing structures. 
    We omit details for 8 instances where both programs run in less than 0.1 seconds. 
  }
  \label{tab:results}
\end{table}

\section{Discussion}

We showed that a constraint-based approach to RNA alignment can be
competitive with the ILP based method Lara for crossing
structures. Moreover, the approach is the first such method that
scores unlimited structure. In this way, it differs from simultaneous
alignment and folding approaches like Lara, which score only crossing
(or even more restricted) substructures of unlimited input
structures. The full potential of scoring unlimited structure and its
biological applications, e.g. for aligning dot-plots of riboswitches
and RNAs with conserved folding dynamics have still to be explored. A
constraint-based method promises flexibility for further extensions
and improvements. Solving relaxed problems in propagators for handling
crossing and unlimited RNA structure was shown to be a viable approach
and appears to be generalizable to related problems.

%\paragraph{Acknowledgments} This work is partially supported by the German
%Research Foundation (DFG grant WI 3628/1-1).
\paragraph{Acknowledgments} This work is partially supported by DFG grant WI 3628/1-1.

\bibliographystyle{plain}
\bibliography{all}

\end{document}
